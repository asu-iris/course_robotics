
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Numerical Inverse Kinematics &#8212; Modeling and Control of Robots</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'lec16-17/nik';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dynamics (Lagrangian formulation)" href="../lec18/dyn.html" />
    <link rel="prev" title="Inverse Velocity Kinematics" href="../lec15/inverse_vk.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/iris_logo_2.png" class="logo__image only-light" alt="Modeling and Control of Robots - Home"/>
    <script>document.write(`<img src="../_static/iris_logo_2.png" class="logo__image only-dark" alt="Modeling and Control of Robots - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../lec1/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lec2/configuration.html">Robot Configuration</a></li>



<li class="toctree-l1"><a class="reference internal" href="../lec3-5/basic-kinematics.html">Basic Kinematics</a></li>





<li class="toctree-l1"><a class="reference internal" href="../lec6-8/fk.html">Forward Kinematics</a></li>






<li class="toctree-l1"><a class="reference internal" href="../lec9/ik.html">Inverse Kinematics</a></li>


<li class="toctree-l1"><a class="reference internal" href="../opt/motion_planning.html">Motion Planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lec10/diff-trans.html">Velocity Kinematics</a></li>

<li class="toctree-l1"><a class="reference internal" href="../lec11-12/jacobian.html">Jacobian</a></li>





<li class="toctree-l1"><a class="reference internal" href="../lec13/singularity.html">Singularity &amp; Redundancy</a></li>


<li class="toctree-l1"><a class="reference internal" href="../lec14/statics.html">Statics</a></li>


<li class="toctree-l1"><a class="reference internal" href="../lec15/inverse_vk.html">Inverse Velocity Kinematics</a></li>



<li class="toctree-l1 current active"><a class="current reference internal" href="#">Numerical Inverse Kinematics</a></li>

<li class="toctree-l1"><a class="reference internal" href="../lec18/dyn.html">Dynamics (Lagrangian formulation)</a></li>




<li class="toctree-l1"><a class="reference internal" href="../lec19/control_overview.html">Overview of Robot Arm Control</a></li>



<li class="toctree-l1"><a class="reference internal" href="../lec20/djc.html">Decentralized Joint Control</a></li>



<li class="toctree-l1"><a class="reference internal" href="../lec21/cjc.html">Centralized Joint Control</a></li>


<li class="toctree-l1"><a class="reference internal" href="../lec22/osc.html">Operational Space Control</a></li>


</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Flec16-17/nik.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button"
   title="Open an issue"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/lec16-17/nik.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Numerical Inverse Kinematics</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Numerical Inverse Kinematics</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#jacobian-inverse-or-newton-raphson-method">Jacobian Inverse or Newton-Raphson Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#jacobian-transpose-or-gradient-based-method">Jacobian Transpose or Gradient-Based Method</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#definition-of-end-effector-error">Definition of End-effector Error</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-angles-error">Euler-Angles Error</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="numerical-inverse-kinematics">
<h1>Numerical Inverse Kinematics<a class="headerlink" href="#numerical-inverse-kinematics" title="Link to this heading">#</a></h1>
<p>Recall IK problems: given a desired end-effector pose
<span class="math notranslate nohighlight">\(\boldsymbol{x}_{d}\)</span> (in operational space), we want to find the joint vector <span class="math notranslate nohighlight">\(\boldsymbol{q}\)</span> such that
<span class="math notranslate nohighlight">\(\boldsymbol{k}(\boldsymbol{q})=\boldsymbol{x}_d\)</span>. Here,
<span class="math notranslate nohighlight">\(\boldsymbol{k}(\cdot)\)</span> is the forward kinematics. In this chapter, we will show how to use Jacobian to solve this problem numerically. Let’s consider</p>
<div class="math notranslate nohighlight">
\[
\dot{\boldsymbol{x}}_{e}=\boldsymbol{J}_{A}(\boldsymbol{q}) \dot{\boldsymbol{q}}
\]</div>
<p>with <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}(\boldsymbol{q})\)</span> is Jacobian (you will see why we use <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}(\boldsymbol{q})\)</span> instead of <span class="math notranslate nohighlight">\(\boldsymbol{J}(\boldsymbol{q})\)</span> to denote the Jacobian at the end of this lecture).</p>
<p>To solve the above IK, we define the following operational space error
between the desired <span class="math notranslate nohighlight">\(\boldsymbol{x}_{d}\)</span> and the current end-effector
pose <span class="math notranslate nohighlight">\(\boldsymbol{x}_{e}\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-equ-error">
<span class="eqno">(23)<a class="headerlink" href="#equation-equ-error" title="Link to this equation">#</a></span>\[\boldsymbol{e}=\boldsymbol{x}_{d}-\boldsymbol{x}_{e}=\boldsymbol{x}_{d}-\boldsymbol{k}(\boldsymbol{q})
\]</div>
<p>Consider the time derivative of <a class="reference internal" href="#equation-equ-error">(23)</a></p>
<div class="math notranslate nohighlight" id="equation-equ-error-dyn">
<span class="eqno">(24)<a class="headerlink" href="#equation-equ-error-dyn" title="Link to this equation">#</a></span>\[\dot{\boldsymbol{e}}=\dot{\boldsymbol{x}}_{d}-\dot{\boldsymbol{x}}_{e}=\dot{\boldsymbol{x}}_{d}-\boldsymbol{J}_{A}(\boldsymbol{q}) \dot{\boldsymbol{q}}\]</div>
<p>The above <a class="reference internal" href="#equation-equ-error-dyn">(24)</a> is called <em>error dynamics</em>, as it show ODE of end-effector pose error
<span class="math notranslate nohighlight">\(\boldsymbol{e}(t)\)</span> over time <span class="math notranslate nohighlight">\(t\)</span>. Here, <span class="math notranslate nohighlight">\(\dot{\boldsymbol{q}}\)</span> can be
viewed as the control input. From a control perspective, we want to find
a feedback control law</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{q}}= \text{Controller}({\boldsymbol{x}}_d, \dot{\boldsymbol{x}}_d,  {\boldsymbol{q}}, {\boldsymbol{e}})\]</div>
<p>such that, when plug the controller to the error dynamics,
<span class="math notranslate nohighlight">\(\boldsymbol{e}(t)\rightarrow 0\)</span> as <span class="math notranslate nohighlight">\(t\rightarrow \infty\)</span>. The different
controllers leads to different  IK algorithms.</p>
<section id="jacobian-inverse-or-newton-raphson-method">
<h2>Jacobian Inverse or Newton-Raphson Method<a class="headerlink" href="#jacobian-inverse-or-newton-raphson-method" title="Link to this heading">#</a></h2>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In Jacobian Inverse IK method, we set
<span class="math notranslate nohighlight">\(\dot{\boldsymbol{q}}= \text{Controller}({\boldsymbol{x}}_d, \dot{\boldsymbol{x}}_d,  {\boldsymbol{q}}, {\boldsymbol{e}})\)</span>
specifically as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\dot{\boldsymbol{q}}=
\begin{cases}
\boldsymbol{J}_{A}^{-1}(\boldsymbol{q})\left(\dot{\boldsymbol{x}}_{d}+\boldsymbol{K} \boldsymbol{e}\right)  \quad\quad\text{for non-redundant robot arms} \\[10pt]
\boldsymbol{J}_{A}^{\dagger}\left(\dot{\boldsymbol{x}}_{d}+\boldsymbol{K e}\right)+\left(\boldsymbol{I}_{n}-\boldsymbol{J}_{A}^{\dagger} \boldsymbol{J}_{A}\right) \dot{\boldsymbol{q}}_{\text{ref}} \quad\quad\text{for redundant robot arms}
\end{cases}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span> is a positive definite (usually diagonal) matrix, and <span class="math notranslate nohighlight">\({\boldsymbol{q}}_{\text{ref}}\)</span> is any reference joint velocity, which can be set based on a second objective in the previous chapter. <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}^{\dagger}\)</span> is the pseudo-inverse of Jacobian: <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}^{\dagger}=\boldsymbol{J}_{A}^{T}\left(\boldsymbol{J}_{A} \boldsymbol{J}_{A}^{T}\right)^{-1}\)</span>.</p>
</div>
<p>Let’s next verify if the above controller can solve the IK or not, by examining if the error dynamics
is converging to 0.
Submitting the above controllers into the error dynamics, it easy to
verify that</p>
<div class="math notranslate nohighlight" id="equation-equ-method1">
<span class="eqno">(25)<a class="headerlink" href="#equation-equ-method1" title="Link to this equation">#</a></span>\[\dot{\boldsymbol{e}}+\boldsymbol{K} \boldsymbol{e}=0 .\]</div>
<p>If <span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span> is a positive definite (usually diagonal) matrix,
<a class="reference internal" href="#equation-equ-method1">(25)</a> is asymptotically stable. The error tends to zero along the
trajectory with a convergence rate that depends on the eigenvalues of
<span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span>.</p>
<div class="admonition-background-from-linear-control-systems-course admonition">
<p class="admonition-title">Background from Linear Control Systems course</p>
<p>Generally, given an ordinary differential equation (ODE)</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{e}}+\boldsymbol{K} \boldsymbol{e}=0\]</div>
<p>the solution
<span class="math notranslate nohighlight">\(\boldsymbol{e}(t)\)</span> to the above ODE is</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{e}(t)=e^{\boldsymbol{-K}t}\boldsymbol{e}(0)\]</div>
<p>In particular, if <span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span> is diagonal, say</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{K}=\begin{bmatrix}
\lambda_1&amp; &amp; &amp;\\
&amp;\lambda_2 &amp; &amp; \\
&amp; &amp; \ddots &amp;\\
&amp; &amp; &amp; \lambda_r
\end{bmatrix},\end{split}\]</div>
<p>the solution is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{e}(t)=\begin{bmatrix}
e^{-\lambda_1t}&amp; &amp; &amp;\\
&amp;e^{-\lambda_2t} &amp; &amp; \\
&amp; &amp; \ddots &amp;\\
&amp; &amp; &amp; e^{-\lambda_rt}
\end{bmatrix}\boldsymbol{e}(0)\end{split}\]</div>
<p>Therefore, only if
<span class="math notranslate nohighlight">\(\lambda_1, \lambda_2, ...\lambda_r&gt;0\)</span>,
<span class="math notranslate nohighlight">\(\boldsymbol{e}(t)\rightarrow \boldsymbol{0}\)</span> as <span class="math notranslate nohighlight">\(t\rightarrow \infty\)</span>.</p>
</div>
<p>The block scheme for the above IK algorithm is shown below (non-redundant robot arm),
where <span class="math notranslate nohighlight">\(\boldsymbol{k}(\cdot)\)</span> means the direct kinematics function.</p>
<figure class="align-default" id="ik-jacobian-inverse">
<a class="reference internal image-reference" href="../_images/IK_jacobian_inverse.jpg"><img alt="../_images/IK_jacobian_inverse.jpg" src="../_images/IK_jacobian_inverse.jpg" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 64 </span><span class="caption-text">IK algorithm with Jacobian
inverse</span><a class="headerlink" href="#ik-jacobian-inverse" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition-why-it-s-also-named-newton-raphson-method admonition">
<p class="admonition-title">Why it’s also named Newton-Raphson method?</p>
<p>The naming of Newton-Raphson method comes from the perspective of “IK as solving nonlinear equations”</p>
<p>Specifically, consider the following nonlinear equation from FK</p>
<div class="math notranslate nohighlight" id="equation-equ-ik-fk">
<span class="eqno">(26)<a class="headerlink" href="#equation-equ-ik-fk" title="Link to this equation">#</a></span>\[\boldsymbol{k}(\boldsymbol{q})=\boldsymbol{x}_d\]</div>
<p>given <span class="math notranslate nohighlight">\(\boldsymbol{x}_d\)</span>.</p>
<p>Assume we have an initial guess <span class="math notranslate nohighlight">\(\boldsymbol{q}_t\)</span>. One
can approximate <a class="reference internal" href="#equation-equ-ik-fk">(26)</a> at <span class="math notranslate nohighlight">\(\boldsymbol{q}_k\)</span> using the
first-order Tyler expension:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{k}(\boldsymbol{q})\approx\boldsymbol{k}(\boldsymbol{q}_t)+\boldsymbol{J}_{A}(\boldsymbol{q}_t)(\boldsymbol{q}-\boldsymbol{q}_t)=\boldsymbol{x}_d\]</div>
<p>By solving the above equation for <span class="math notranslate nohighlight">\(\boldsymbol{q}\)</span>, one can obtain the
next updated guess</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{q}_{t+1}=\boldsymbol{q}_t+\text{inv}\left(\boldsymbol{J}_{A}(\boldsymbol{q}_t)\right)(\boldsymbol{x}_d-\boldsymbol{t}(\boldsymbol{q}_t))=\boldsymbol{q}_t+\text{inv}\left(\boldsymbol{J}_{A}(\boldsymbol{q}_t)\right)\boldsymbol{e}_t\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{inv}\)</span> is the general inverse operation (inverse for square
matrix or pseudo-inverse for non-square matrix). Typically, one also
needs a step size before
<span class="math notranslate nohighlight">\(\text{inv}\left(\boldsymbol{J}_{A}(\boldsymbol{q}_t)\right)\)</span> to stabilize
the Newton-Raphson algorithm. The above results can be considered as the
discrete-time version of the Jacobian Inverse IK algorithm with
<span class="math notranslate nohighlight">\(\dot{\boldsymbol{x}}_d=\boldsymbol{0}\)</span>.</p>
</div>
</section>
<section id="jacobian-transpose-or-gradient-based-method">
<h2>Jacobian Transpose or Gradient-Based Method<a class="headerlink" href="#jacobian-transpose-or-gradient-based-method" title="Link to this heading">#</a></h2>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In Jacobian Transpose IK method, we set
<span class="math notranslate nohighlight">\(\dot{\boldsymbol{q}}= \text{Controller}({\boldsymbol{x}}_d, \dot{\boldsymbol{x}}_d,  {\boldsymbol{q}}, {\boldsymbol{e}})\)</span>
specifically as</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{q}}=\boldsymbol{J}_{A}^{T}(\boldsymbol{q}) \boldsymbol{K} \boldsymbol{e}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span> is a positive definite (usually diagonal) matrix,</p>
</div>
<p>Let’s next find out if the above controller can solve the IK or not, by using the Lyapunov Stability.</p>
<div class="admonition-background-about-lyapunov-stability admonition">
<p class="admonition-title">Background about Lyapunov Stability</p>
<p>Consider the following error dynamics (ODE)</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{x}}(t)=\boldsymbol{f}(\boldsymbol{x}),\quad \text{given}\quad \boldsymbol{x}(0)\]</div>
<p>If there exists a Lyapunov function <span class="math notranslate nohighlight">\(V(\boldsymbol{x})\)</span> such that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V(\boldsymbol{x})&gt;0 \quad \forall \boldsymbol{x} \neq \mathbf{0}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V(\mathbf{0})=0 \quad \text{only for} \quad \boldsymbol{x}=\boldsymbol{0}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\dot{V}=\frac{dV}{dt}=(\frac{d V}{d\boldsymbol{x}})^T\dot{\boldsymbol{x}}=(\frac{d V}{d\boldsymbol{x}})^T \boldsymbol{f}(\boldsymbol{x})&lt;0 \quad \forall \boldsymbol{x}\)</span></p></li>
</ul>
<p>then, <span class="math notranslate nohighlight">\({\boldsymbol{x}}(t)\rightarrow \boldsymbol{0}\)</span> as
<span class="math notranslate nohighlight">\(t\rightarrow \infty\)</span> (the error is converging).</p>
</div>
<p>Consider <span class="math notranslate nohighlight">\(\dot{\boldsymbol{x}}_{d}=\mathbf{0}\)</span>. Let’s use Lyapunov
function to find controller such that the error dynamics <a class="reference internal" href="#equation-equ-error-dyn">(24)</a> is
stablizing. Let’s choose Lyapunov function</p>
<div class="math notranslate nohighlight">
\[V(\boldsymbol{e})=\frac{1}{2} \boldsymbol{e}^{T} \boldsymbol{K} \boldsymbol{e}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{K}\)</span> is a symmetric positive definite matrix.
Obviously,</p>
<div class="math notranslate nohighlight">
\[V(\boldsymbol{e})&gt;0 \quad \forall \boldsymbol{e} \neq \mathbf{0}, \quad V(\mathbf{0})=0 \quad \text{only for} \quad \boldsymbol{e}=\boldsymbol{0}\]</div>
<p>Differentiating <span class="math notranslate nohighlight">\(V(\boldsymbol{e})\)</span> with respect to time gives</p>
<div class="math notranslate nohighlight">
\[\dot{V}=\boldsymbol{e}^{T} \boldsymbol{K} \dot{\boldsymbol{x}}_{d}-\boldsymbol{e}^{T} \boldsymbol{K} \dot{\boldsymbol{x}}_{e}=\boldsymbol{e}^{T} \boldsymbol{K} \dot{\boldsymbol{x}}_{d}-\boldsymbol{e}^{T} \boldsymbol{K} \boldsymbol{J}_{A}(\boldsymbol{q}) \dot{\boldsymbol{q}}\]</div>
<p>At this point, since <span class="math notranslate nohighlight">\(\boldsymbol{\dot{x}}_d=\boldsymbol{0}\)</span>, if we
choose</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{q}}=\boldsymbol{J}_{A}^{T}(\boldsymbol{q}) \boldsymbol{K} \boldsymbol{e}\]</div>
<p>This leads to</p>
<div class="math notranslate nohighlight">
\[\dot{V}=-\boldsymbol{e}^{T} \boldsymbol{K} \boldsymbol{J}_{A}(\boldsymbol{q}) \boldsymbol{J}_{A}^{T}(\boldsymbol{q}) \boldsymbol{K} \boldsymbol{e}\]</div>
<p><span class="math notranslate nohighlight">\(\dot{V}\)</span> is negative definite, under the assumption of full rank for
<span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}(\boldsymbol{q})\)</span>. <span class="math notranslate nohighlight">\(\dot{V}&lt;0\)</span> with <span class="math notranslate nohighlight">\(V&gt;0\)</span> implies the
error dynamics will stabilize to <span class="math notranslate nohighlight">\(\boldsymbol{e}=\mathbf{0}\)</span>,
according to Lyapunov Stablity. The block scheme for the Jacobian transpose IK algorithm is  shown below.</p>
<figure class="align-default" id="ik-jacobian-transpose">
<a class="reference internal image-reference" href="../_images/IK_jacobian_transpose.jpg"><img alt="../_images/IK_jacobian_transpose.jpg" src="../_images/IK_jacobian_transpose.jpg" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 65 </span><span class="caption-text">Block scheme of the inverse kinematics algorithm with Jacobian
transpose</span><a class="headerlink" href="#ik-jacobian-transpose" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition-why-it-s-also-named-gradient-based-method admonition">
<p class="admonition-title">Why it’s also named Gradient-Based Method?</p>
<p>Specifically, when <span class="math notranslate nohighlight">\(\dot{\boldsymbol{x}}_d=\boldsymbol{0}\)</span>, consider we
want to find the joint value <span class="math notranslate nohighlight">\(\boldsymbol{q}\)</span> by minimizing the error of</p>
<div class="math notranslate nohighlight">
\[\min_{\boldsymbol{q}}\quad\frac{1}{2}||\boldsymbol{k}(\boldsymbol{q})-\boldsymbol{x}_d||^2\]</div>
<p>The gradient descent to update current guess <span class="math notranslate nohighlight">\(\boldsymbol{q}_k\)</span> to next
<span class="math notranslate nohighlight">\(\boldsymbol{q}_{k+1}\)</span></p>
<div class="math notranslate nohighlight">
\[\boldsymbol{q}_{k+1}=\boldsymbol{q}_{k}-\alpha{\left(\frac{d\boldsymbol{k}(\boldsymbol{q})}{d\boldsymbol{q}}\bigg\rvert_{\boldsymbol{q}=\boldsymbol{q}_k}\right)}^{T}(\boldsymbol{k}(\boldsymbol{q})-\boldsymbol{x}_d)=\boldsymbol{q}_{k}+\alpha{\boldsymbol{J}_{A}(\boldsymbol{q}_k)}^{T}\boldsymbol{e}_k\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the gradient step size. The above results can be
considered as the discrete-time version of the Jacobian transpose
IK algorithm if <span class="math notranslate nohighlight">\(\boldsymbol{\dot{x}}_d=0\)</span>.</p>
</div>
<!-- 
## More Discussion 

When $\dot{\boldsymbol{x}}_{d} = \mathbf{0}$ and
$\mathcal{N}\left(\boldsymbol{J}_{A}^{T}\right) \neq \emptyset$,
$\dot{V}$ is only negative semi-definite, since $\dot{V}=0$ for
$\boldsymbol{e} \neq \mathbf{0}$ with
$\boldsymbol{K} \boldsymbol{e} \in \mathcal{N}\left(\boldsymbol{J}_{A}^{T}\right)$.
In this case, the algorithm can get stuck at
$\dot{\boldsymbol{q}}=\mathbf{0}$ with $\boldsymbol{e} \neq \mathbf{0}$.

When $\dot{\boldsymbol{x}}_{d} \neq \mathbf{0}$, in order to obtain
$\dot{V}<0$ also in this case, it would be sufficient to choose

$$\dot{\boldsymbol{q}}=
\begin{cases}
\boldsymbol{J}_{A}^{-1}\left(\dot{\boldsymbol{x}}_{d}+\boldsymbol{K} \boldsymbol{e}\right)  \quad\quad\text{for non-redundant manipulators} \\
\boldsymbol{J}_{A}^{\dagger}\left(\dot{\boldsymbol{x}}_{d}+\boldsymbol{K e}\right)+\left(\boldsymbol{I}_{n}-\boldsymbol{J}_{A}^{\dagger} \boldsymbol{J}_{A}\right) \dot{\boldsymbol{q}}_{0} \quad\quad\text{for redundant manipulators}
\end{cases}$$

which is exactly the Jacobian inverse controller introduced in the first
section.

Furthermore, we have the following comments on the above Jacobian
transpose controller.

-   In the case of kinematic singularities, we have to use Jacobian
    transpose IK because it does not require the inverse/pseudo-inverse
    of the Jacobian

-   Although the Jacobian transpose IK cannot guarantee the convergence
    of the error dynamics when
    $\dot{\boldsymbol{x}}_{d} \neq \mathbf{0}$, the tracking error
    $\boldsymbol{e}(t)$ is norm-bounded. This is because, when the error
    norm is small, the linear term (the first term in $\dot{V}(t)$)
    prevails in the second quadratic term; when otherwise, the quadratic
    term dominates, dragging the error to the small norm. -->
</br>
</br>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="definition-of-end-effector-error">
<h1>Definition of End-effector Error<a class="headerlink" href="#definition-of-end-effector-error" title="Link to this heading">#</a></h1>
<p>Both IK algorithms above  require computing the end-effector error. It is straightforward to define the position
error of the end-effector</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{e}_{P}=\boldsymbol{p}_{d}-\boldsymbol{p}_{e}(\boldsymbol{q})\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{p}_{d}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{p}_{e}\)</span> denote respectively
the desired and computed end-effector positions. Its time derivative is</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{e}}_{P}=\dot{\boldsymbol{p}}_{d}-\dot{\boldsymbol{p}}_{e} .\]</div>
<p>However, the problem arises when we define the end-effector orientation
error. In the
following, let’s consider the typical Euler-Angles
representations and its error definition.</p>
<section id="euler-angles-error">
<h2>Euler-Angles Error<a class="headerlink" href="#euler-angles-error" title="Link to this heading">#</a></h2>
<p>The orientation error using Euler angles is</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{e}_{O}=\boldsymbol{\phi}_{d}-\boldsymbol{\phi}_{e}(\boldsymbol{q})\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_{d}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_{e}\)</span> denote
respectively the desired and computed Euler angles of the end-effector. Its time
derivative is</p>
<div class="math notranslate nohighlight">
\[\dot{\boldsymbol{e}}_{O}=\dot{\boldsymbol{\phi}}_{d}-\dot{\boldsymbol{\phi}}_{e}\]</div>
<p>In order to apply any of the above IK algorithms, we need to find a Jacobian in terms of</p>
<div class="math notranslate nohighlight">
\[\begin{split}\dot{\boldsymbol{x}}_{e}=\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{e} \\
\dot{\boldsymbol{\phi}}_{e}
\end{array}\right]
=
\boldsymbol{J}_{A} \dot{\boldsymbol{q}}
=
\begin{bmatrix}
\boldsymbol{J}_{P}(\boldsymbol{q})\\
\boldsymbol{J}_{\phi}(\boldsymbol{q})
\end{bmatrix}
\dot{\boldsymbol{q}}
\end{split}\]</div>
<p>As you can see, compared to the Jacobian <span class="math notranslate nohighlight">\(
\boldsymbol{J}=\begin{bmatrix}
\boldsymbol{J}_{P}(\boldsymbol{q})\\
\boldsymbol{J}_{O}(\boldsymbol{q})
\end{bmatrix}\)</span>  we have learned in the Jacobian lecture, the linear Jacobian <span class="math notranslate nohighlight">\(\boldsymbol{J}_{P}(\boldsymbol{q})\)</span> remains the same as before, the only difference is the angular Jacobian <span class="math notranslate nohighlight">\(\boldsymbol{J}_{O}(\boldsymbol{q})\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[
\dot{\boldsymbol{\phi}}_{e}=
\boldsymbol{J}_{\phi}(\boldsymbol{q}) \dot{\boldsymbol{q}}
\]</div>
<p>We call the new Jacobian matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{J}_{A}(\boldsymbol{q})=\begin{bmatrix}
\boldsymbol{J}_{P}(\boldsymbol{q})\\
\boldsymbol{J}_{\phi}(\boldsymbol{q})
\end{bmatrix}
\end{split}\]</div>
<p>the <em>analytical Jacobian</em>(recall <span class="math notranslate nohighlight">\(\boldsymbol{J}\)</span> is called geometrical Jacobian or Jacobian). This is the reason why we in the above used <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}\)</span> instead of <span class="math notranslate nohighlight">\(\boldsymbol{J}\)</span>!</p>
<p>Next question, how do we find <span class="math notranslate nohighlight">\(\boldsymbol{J}_{A}(\boldsymbol{q})\)</span> from <span class="math notranslate nohighlight">\(\boldsymbol{J}\)</span>? To do so,  we may need find a mapping</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{e} \\
\boldsymbol{\omega}_{e}
\end{array}\right] =  \underbrace{\begin{bmatrix}
\boldsymbol{I} &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; \boldsymbol{N}\left(\phi_{e}\right)
\end{bmatrix}}_{\boldsymbol{T}}
\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{e} \\
\dot{\boldsymbol{\phi}}_{e}
\end{array}\right]\end{split}\]</div>
<p>such that</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{J}_{A}(\boldsymbol{q}) = \boldsymbol{T}^{-1} \boldsymbol{J}(\boldsymbol{q})\]</div>
<p>In the following, we will find out the mapping</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\omega}_{e}=\boldsymbol{N}\left(\phi_{e}\right)\dot{\boldsymbol{\phi}}_{e}\]</div>
<p>for the Euler ZYZ Angle
<span class="math notranslate nohighlight">\({\boldsymbol{\phi}}_{e}=[{\varphi}, {\vartheta}, \psi]^T\)</span>.</p>
<p>Recall the rotation induced from the Euler ZYZ Angle. The angualr velocities <span class="math notranslate nohighlight">\(\dot{\varphi}, \dot{\vartheta}, \dot\psi\)</span> is always with respect to the current frame, as shown in <a class="reference internal" href="#euler-angle-vel"><span class="std std-numref">Fig. 66</span></a>.</p>
<figure class="align-default" id="euler-angle-vel">
<a class="reference internal image-reference" href="../_images/Euler_angle_vel.jpg"><img alt="../_images/Euler_angle_vel.jpg" src="../_images/Euler_angle_vel.jpg" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 66 </span><span class="caption-text">Rotational velocities of Euler angles ZYZ in current
frame</span><a class="headerlink" href="#euler-angle-vel" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Therefore, to compute <span class="math notranslate nohighlight">\(\boldsymbol{\omega}_{e}\)</span>, we just need to first,  express each Euler angle velocity <span class="math notranslate nohighlight">\(\dot{\varphi}, \dot{\vartheta}, \dot\psi\)</span> from its respective current from to the reference
frame, and second, sum them up!</p>
<ul class="simple">
<li><p>The angular velocity corresponding to <span class="math notranslate nohighlight">\(\dot{\varphi}\)</span> is</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\dot{\varphi}\left[\begin{array}{lll}0 &amp; 0 &amp; 1\end{array}\right]^{T}\]</div>
<ul class="simple">
<li><p>The angular velocity corresponding to  <span class="math notranslate nohighlight">\(\dot{\vartheta}\)</span> is</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\dot{\vartheta}\left[\begin{array}{lll}-s_{\varphi} &amp; c_{\varphi} &amp; 0\end{array}\right]^{T}\]</div>
<ul class="simple">
<li><p>The angular velocity corresponding to <span class="math notranslate nohighlight">\(\dot{\psi}\)</span> is</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\dot{\psi}\left[\begin{array}{lll}c_{\varphi} s_{\vartheta} &amp; s_{\varphi} s_{\vartheta} &amp; c_{\vartheta}\end{array}\right]^{T}\]</div>
<p>Thus,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{N}\left(\phi_{e}\right) =\left[\begin{array}{ccc}
0 &amp; -s_{\varphi} &amp; c_{\varphi} s_{\vartheta} \\
0 &amp; c_{\varphi} &amp; s_{\varphi} s_{\vartheta} \\
1 &amp; 0 &amp; c_{\vartheta}
\end{array}\right] .\end{split}\]</div>
<!-- 





## Angle-Axis Error (Optional)
If the desired orientation of the end-effector is given in rotation
matrix
$\boldsymbol{R}_{d}=\left[\begin{array}{lll}\boldsymbol{n}_{d} & \boldsymbol{s}_{d} & \boldsymbol{a}_{d}\end{array}\right]$
and current end-effector's rotation matrix is
$\boldsymbol{R}_{e}(\boldsymbol{q})=\left[\begin{array}{lll}\boldsymbol{n}_{e}(\boldsymbol{q}) & \boldsymbol{s}_{e}(\boldsymbol{q}) & \boldsymbol{a}_{e}(\boldsymbol{q})\end{array}\right]$,
the orientation error vector can be defined as

$$\boldsymbol{e}_{O}=\boldsymbol{r} \sin \vartheta$$

where $\vartheta$ and $\boldsymbol{r}$ are the angle and axis of the
rotation needed to align $\boldsymbol{R}$ with $\boldsymbol{R}_{d}$

$$\boldsymbol{R}(\vartheta, \boldsymbol{r})=\boldsymbol{R}_{d} \boldsymbol{R}_{e}^{T}(\boldsymbol{q})$$

Via derivation, one can also obtain

$$\boldsymbol{e}_{O}=\frac{1}{2}\left(\boldsymbol{n}_{e}(\boldsymbol{q}) \times \boldsymbol{n}_{d}+\boldsymbol{s}_{e}(\boldsymbol{q}) \times \boldsymbol{s}_{d}+\boldsymbol{a}_{e}(\boldsymbol{q}) \times \boldsymbol{a}_{d}\right)$$

Differentiating the above error vector with respect to time

$$\dot{\boldsymbol{e}}_{O}=\boldsymbol{L}^{T} \boldsymbol{\omega}_{d}-\boldsymbol{L} \boldsymbol{\omega}_{e}$$

with

$$\boldsymbol{L}=-\frac{1}{2}\left(\boldsymbol{S}\left(\boldsymbol{n}_{d}\right) \boldsymbol{S}\left(\boldsymbol{n}_{e}\right)+\boldsymbol{S}\left(\boldsymbol{s}_{d}\right) \boldsymbol{S}\left(\boldsymbol{s}_{e}\right)+\boldsymbol{S}\left(\boldsymbol{a}_{d}\right) \boldsymbol{S}\left(\boldsymbol{a}_{e}\right)\right)$$

where $\boldsymbol{S}(\cdot)$ is the skew-symmetric operator. The
operational space error

$$\dot{\boldsymbol{e}}=\left[\begin{array}{c}
\dot{\boldsymbol{e}}_{P} \\
\dot{\boldsymbol{e}}_{O}
\end{array}\right]=\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{d}-\boldsymbol{J}_{P}(\boldsymbol{q}) \dot{\boldsymbol{q}} \\
\boldsymbol{L}^{T} \boldsymbol{\omega}_{d}-\boldsymbol{L} \boldsymbol{J}_{O}(\boldsymbol{q}) \dot{\boldsymbol{q}}
\end{array}\right]=\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{d} \\
\boldsymbol{L}^{T} \boldsymbol{\omega}_{d}
\end{array}\right]-\left[\begin{array}{cc}
\boldsymbol{I} & \boldsymbol{O} \\
\boldsymbol{O} & \boldsymbol{L}
\end{array}\right] \boldsymbol{J} \dot{\boldsymbol{q}}$$

To ensure the error dynamics above is converging to
$\boldsymbol{e}=\boldsymbol{0}$, the Jacobian-inverse controller will be

$$\dot{\boldsymbol{q}}=
\begin{cases}
\boldsymbol{J}^{-1} \boldsymbol{v}  \quad\quad\text{for non-redundant manipulators} \\
\boldsymbol{J}^{\dagger}\boldsymbol{v}+\left(\boldsymbol{I}_{n}-\boldsymbol{J}^{\dagger} \boldsymbol{J}\right) \dot{\boldsymbol{q}}_{0} \quad\quad\text{for redundant manipulators}
\end{cases}$$

with

$$\boldsymbol{v}=\left[\begin{array}{c}
\dot{\boldsymbol{p}}_{d}+\boldsymbol{K}_{P} \boldsymbol{e}_{P} \\
\boldsymbol{L}^{-1}\left(\boldsymbol{L}^{T} \boldsymbol{\omega}_{d}+\boldsymbol{K}_{O} \boldsymbol{e}_{O}\right)
\end{array}\right]$$

## Quaternion Error (Optional)

If the desired orientation is given in quaternion
$\mathcal{Q}_{d}=\left\{\eta_{d}, \boldsymbol{\epsilon}_{d}\right\}$ and
current quaternion of end-effector is
$\mathcal{Q}_{e}=\left\{\eta_{e}, \boldsymbol{\epsilon}_{e}\right\}$,
one can define an error quaternion
$\Delta \mathcal{Q}=\{\Delta \eta, \Delta \epsilon\}$

$$\Delta \mathcal{Q}=\mathcal{Q}_{d} * \mathcal{Q}_{e}^{-1}$$

which represents the rotation needed to align $\mathcal{Q}_{e}$ and
$\mathcal{Q}_{d}$. $\Delta \mathcal{Q}=\{1, \mathbf{0}\}$ if and only if
$\mathcal{Q}_{e}$ and $\mathcal{Q}_{d}$ are aligned. From the above
error quaternion, one can define the orientation error vector

$$\boldsymbol{e}_{O}=\Delta \boldsymbol{\epsilon}=\eta_{e}(\boldsymbol{q}) \boldsymbol{\epsilon}_{d}-\eta_{d} \boldsymbol{\epsilon}_{e}(\boldsymbol{q})-\boldsymbol{S}\left(\boldsymbol{\epsilon}_{d}\right) \boldsymbol{\epsilon}_{e}(\boldsymbol{q})$$

where $\boldsymbol{S}(\cdot)$ is the skew-symmetric operator. At this
point, we define

$$\boldsymbol{v}=\left[\begin{array}{l}
\dot{\boldsymbol{p}}_{d}+\boldsymbol{K}_{P} \boldsymbol{e}_{P} \\
\boldsymbol{\omega}_{d}+\boldsymbol{K}_{O} \boldsymbol{e}_{O}
\end{array}\right]$$

and set the Jacobian-inverse controller

$$\dot{\boldsymbol{q}}=
\begin{cases}
\boldsymbol{J}^{-1} \boldsymbol{v}  \quad\quad\text{for non-redundant manipulators} \\
\boldsymbol{J}^{\dagger}\boldsymbol{v}+\left(\boldsymbol{I}_{n}-\boldsymbol{J}^{\dagger} \boldsymbol{J}\right) \dot{\boldsymbol{q}}_{0} \quad\quad\text{for redundant manipulators}
\end{cases}$$

Next, we will show using the above controller, we will achieve the
convergence of $\mathcal{Q}_{e}$ to $\mathcal{Q}_{d}$. To do so, we
define the following Lyapunov function

$$V=\left(\eta_{d}-\eta_{e}\right)^{2}+\left(\boldsymbol{\epsilon}_{d}-\boldsymbol{\epsilon}_{e}\right)^{T}\left(\boldsymbol{\epsilon}_{d}-\boldsymbol{\epsilon}_{e}\right)$$

It can be shown that

$$\dot{V}=-\boldsymbol{e}_{O}^{T} \boldsymbol{K}_{O} \boldsymbol{e}_{O}$$

To prove the above, we will need to use the following relationships

$$\boldsymbol\omega_{d}-\boldsymbol\omega_{e}+\boldsymbol{K}_{O} \boldsymbol{e}_{O}=\mathbf{0}$$

which is a result of
$\dot{\boldsymbol{\omega}}_{O}=\boldsymbol{J}_{O}\dot{\boldsymbol{q}}$,
and the quaternion derivatives

$$\begin{aligned}
\dot{\eta}_{e} & =-\frac{1}{2} \boldsymbol{\epsilon}_{e}^{T} \boldsymbol{\omega}_{e} \\
\dot{\boldsymbol{\epsilon}}_{e} & =\frac{1}{2}\left(\eta_{e} \boldsymbol{I}_{3}-\boldsymbol{S}\left(\boldsymbol{\epsilon}_{e}\right)\right) \boldsymbol{\omega}_{e}
\end{aligned} \qquad\qquad
\begin{aligned}
\dot{\eta}_{d} & =-\frac{1}{2} \boldsymbol{\epsilon}_{d}^{T} \boldsymbol{\omega}_{d} \\
\dot{\boldsymbol{\epsilon}}_{d} & =\frac{1}{2}\left(\eta_{e} \boldsymbol{I}_{3}-\boldsymbol{S}\left(\boldsymbol{\epsilon}_{d}\right)\right) \boldsymbol{\omega}_{d}
\end{aligned}$$ -->
<!-- # Second-Order IK Algorithms 

The above IK algorithms can be defined as first-order algorithms,
meaning that they convert a motion trajectory, specified at the
end-effector in terms of its poses and velocities, into the equivalent
joint positions and velocities. Nevertheless, for control purposes, it
may be necessary to convert a motion trajectory specified in terms of
position, velocity and acceleration into the joint position, velocity
and acceleration.

The time differentiation of the differential kinematics leads to

$$\ddot{\boldsymbol{x}}_{e}=\boldsymbol{J}_{A}(\boldsymbol{q}) \ddot{\boldsymbol{q}}+\dot{\boldsymbol{J}}_{A}(\boldsymbol{q}, \dot{\boldsymbol{q}}) \dot{\boldsymbol{q}}$$

which gives the relationship between the joint accelerations and the
operational space accelerations. Following the previous route of
defining position and velocity error, we may define the following
acceleration error:

$$\ddot{\boldsymbol{e}}=\ddot{\boldsymbol{x}}_{d}-\ddot{\boldsymbol{x}}_{e}=\ddot{\boldsymbol{x}}_{d}-\boldsymbol{J}_{A}(\boldsymbol{q}) \ddot{\boldsymbol{q}}-\dot{\boldsymbol{J}}_{A}(\boldsymbol{q}, \dot{\boldsymbol{q}}) \dot{\boldsymbol{q}}$$

Assuming square and non-singular matrix $\boldsymbol{J}_{A}$, we may
choose the controller

$$\ddot{\boldsymbol{q}}=\boldsymbol{J}_{A}^{-1}(\boldsymbol{q})\left(\ddot{\boldsymbol{x}}_{d}+\boldsymbol{K}_{D} \dot{\boldsymbol{e}}+\boldsymbol{K}_{P} \boldsymbol{e}-\dot{\boldsymbol{J}}_{A}(\boldsymbol{q}, \dot{\boldsymbol{q}}) \dot{\boldsymbol{q}}\right)$$

where $\boldsymbol{K}_{D}$ and $\boldsymbol{K}_{P}$ are positive
definite matrices. This controller leads to the equivalent linear error
system

$$\ddot{\boldsymbol{e}}+\boldsymbol{K}_{D} \dot{\boldsymbol{e}}+\boldsymbol{K}_{P} \boldsymbol{e}=\mathbf{0}$$

which is asymptotically stable: the error tends to zero along the
trajectory with a convergence speed depending on the choice of
$\boldsymbol{K}_{P}$ and $\boldsymbol{K}_{D}$. The second-order inverse
kinematics algorithm is illustrated below.


```{figure} ../lec11-12/diff_kinematics/IK_second_order.jpg
---
width: 80%
name: IK_second_order
---
Block scheme of the second-order inverse kinematics algorithm with
Jacobian
inverse
```



In the case of a redundant manipulator, the controller is

$$\ddot{\boldsymbol{q}}=\boldsymbol{J}_{A}^{\dagger}\left(\ddot{\boldsymbol{x}}_{d}+\boldsymbol{K}_{D} \dot{\boldsymbol{e}}+\boldsymbol{K}_{P} \boldsymbol{e}-\dot{\boldsymbol{J}}_{A}(\boldsymbol{q}, \dot{\boldsymbol{q}}) \dot{\boldsymbol{q}}\right)+\left(\boldsymbol{I}_{n}-\boldsymbol{J}_{A}^{\dagger} \boldsymbol{J}_{A}\right) \ddot{\boldsymbol{q}}_{0}$$

where the vector $\ddot{\boldsymbol{q}}_{0}$ represents arbitrary joint
accelerations chosen to optimize another objective function. -->
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./lec16-17"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../lec15/inverse_vk.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Inverse Velocity Kinematics</p>
      </div>
    </a>
    <a class="right-next"
       href="../lec18/dyn.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Dynamics (Lagrangian formulation)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Numerical Inverse Kinematics</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#jacobian-inverse-or-newton-raphson-method">Jacobian Inverse or Newton-Raphson Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#jacobian-transpose-or-gradient-based-method">Jacobian Transpose or Gradient-Based Method</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#definition-of-end-effector-error">Definition of End-effector Error</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-angles-error">Euler-Angles Error</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Wanxin Jin @ IRIS Lab
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>